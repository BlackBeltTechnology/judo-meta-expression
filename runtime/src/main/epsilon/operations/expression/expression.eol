// Utility for EVLs: get switch expression of a given switch case.
@cached
operation EXPR!SwitchCase getSwitchExpression() {
    return EXPR!SwitchExpression.all.selectOne(e | e.cases.contains(self));
}

// Utility for EVLs: check if dimension is defined for a given numeric expression.
@cached
operation EXPR!NumericExpression isDimensionDefined() {
    var dimension = modelAdapter.getDimension(self);
    return dimension.isPresent() and not dimension.get().isEmpty();
}

/*
@cached
operation EXPR!Expression isComplete() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self) or (e.isKindOf(EXPR!ReferenceExpression) and e.getLambdaFunctions().contains(self))).isDefined();
}

@cached
operation EXPR!Expression isFragment() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self)).isDefined();
}

@cached
operation EXPR!Expression isLambdaFunction() : Boolean {
    return self.getLambdaContainer().isDefined();
}

@cached
operation EXPR!Expression getLambdaContainer() : EXPR!ReferenceExpression {
    return EXPR!ReferenceExpression.all.selectOne(e | e.getLambdaFunctions().contains(self));
}

@cached
operation EXPR!Expression getFragment() : EXPR!Expression {
    var fragment = EXPR!Expression.all.selectOne(e | e.getOperands().contains(self));
    if (fragment.isDefined()) {
        return fragment.getFragment();
    } else {
        return self;
    }
}

@cached
operation EXPR!Expression getBaseExpressions() : Collection {
    if (self.isKindOf(EXPR!AggregatedExpression)) {
        return Set{self};
    } else {
	    var inputs = self.getOperands();
	    if (not inputs.isEmpty()) {
	        return inputs.collect(i | i.getBaseExpressions()).flatten();
	    } else {
	        return Set{self};
	    }
    }
}

@cached
operation EXPR!Expression getLambdaBasePath() : Collection {
    if (not self.isLambdaFunction()) {
        return Set{};
    }
    
    var result = new Set;
    
    var containers = Set{self.getLambdaContainer()};
    var basePathEntries = containers.collect(e | e.getOperands()).flatten();
    for (bpe in basePathEntries) {
        var navigationSources = Set{bpe};
        
        while (not navigationSources.isEmpty()) {
            var nextNavigationSources = new Set;
            for (ns in navigationSources) {
                if (ns.isKindOf(EXPR!ReferenceExpression)) {
                    result.add(ns);
                    if (ns.getOperands().isEmpty()) {
                        var lambdaContainer = ns.getFragment().getLambdaContainer();
                        if (lambdaContainer.isDefined()) {
                            nextNavigationSources.add(lambdaContainer);
                        }
                    } else {
                        nextNavigationSources.addAll(ns.getOperands());
                    }
                } else {
                    result.add(ns);
                }
            }
            navigationSources = nextNavigationSources;
        }
    }
    
    return result;
}
*/