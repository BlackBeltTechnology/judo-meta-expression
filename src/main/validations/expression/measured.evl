context EXPR!MeasuredInteger {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved")
        
        check: self.getMeasure().isDefined()
        message: "Measure of integer constant is invalid: " + self.measure.toString()
    }
    
    constraint UnitIsInvalid {
        guard: self.satisfiesAll("Resolved", "MeasureIsValid") and self.isMeasured()
        
        check: self.getUnit().isDefined()
        message: "Unit name of measure " + self.measure.toString() + " is invalid: " + self.unitName
    }
}

context EXPR!MeasuredDecimal {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved")
        
        check: self.getMeasure().isDefined()
        message: "Measure of decimal constant is invalid: " + self.measure.toString()
    }
    
    constraint UnitIsInvalid {
        guard: self.satisfiesAll("Resolved", "MeasureIsValid") and self.isMeasured()
        
        check: self.getUnit().isDefined()
        message: "Unit name of measure " + self.measure.toString() + " is invalid: " + self.unitName
    }
}

context EXPR!IntegerAttribute {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved")
        
        check: not self.isMeasured() or self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!DecimalAttribute {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved")
        
        check: not self.isMeasured() or self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerAritmeticExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.left.satisfiesAll("MeasureIsValid") and self.right.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!DecimalAritmeticExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.left.satisfiesAll("MeasureIsValid") and self.right.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerOppositeExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!DecimalOppositeExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerAggregatedExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!DecimalAggregatedExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerOppositeExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!RoundExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerOppositeExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured() and self.expression.satisfiesAll("MeasureIsValid")
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
}

context EXPR!IntegerSwitchExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured()
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
    
    // TODO - check measure of cases
}

context EXPR!DecimalSwitchExpression {
    constraint MeasureIsValid {
        guard: self.satisfiesAll("Resolved") and self.isMeasured()
        
        check: self.getMeasure().isDefined()
        message: "Measure of expression is invalid: " + self.toString()
    }
    
    // TODO - check measure of cases
}