@cached
operation EXPR!NumericAttribute isMeasured() {
    return self.getAttributeType().isMeasured();
}

@cached
operation EXPR!NumericAttribute getMeasure() {
    if (self.isMeasured()) {
        return JUDOPSM!Measure.all.selectOne(m | m.units.contains(self.getUnit())); 
    } else {
        return null;
    }
}

@cached
operation EXPR!NumericAttribute getUnit() : JUDOPSM!Unit {
    if (self.isMeasured()) {
        return self.getAttributeType().getUnit();
    } else {
        return null;
    }
}

@cached
operation EXPR!MeasuredDecimal getMeasure() {
    return self.measure.getMeasure();
}

@cached
operation EXPR!MeasuredDecimal getUnit() {
    var measure = self.getMeasure();
    if (measure.isDefined()) {
        return self.getMeasure().getUnit(self.unitName);
    } else {
        return null;
    }
}

@cached
operation EXPR!MeasuredInteger getMeasure() {
    return self.measure.getMeasure();
}

@cached
operation EXPR!MeasuredInteger getUnit() {
    var measure = self.getMeasure();
    if (measure.isDefined()) {
        return self.getMeasure().getUnit(self.unitName);
    } else {
        return null;
    }
}

@cached
operation EXPR!CountExpression isMeasured() : Boolean {
    return false;
}

@cached
operation EXPR!IntegerAritmeticExpression isMeasured() : Boolean {
    return self.left.isMeasured() or self.right.isMeasured();
}

@cached
operation EXPR!DecimalAritmeticExpression isMeasured() : Boolean {
    return self.left.isMeasured() or self.right.isMeasured();
}

@cached
operation EXPR!IntegerOppositeExpression isMeasured() : Boolean {
    return self.expression.isMeasured();
}

@cached
operation EXPR!DecimalOppositeExpression isMeasured() : Boolean {
    return self.expression.isMeasured();
}

@cached
operation EXPR!IntegerAggregatedExpression isMeasured() : Boolean {
    return self.expression.isMeasured();
}

@cached
operation EXPR!DecimalAggregatedExpression isMeasured() : Boolean {
    return self.expression.isMeasured();
}

@cached
operation EXPR!RoundExpression isMeasured() : Boolean {
    return self.expression.isMeasured();
}

@cached
operation EXPR!IntegerSwitchExpression isMeasured() : Boolean {
    var foundMeasuredOperand = false;
    if (self.defaultExpression.isDefined()) {
        foundMeasuredOperand = foundMeasuredOperand or self.defaultExpression.isMeasured();
    }
    for (c in self.cases) {
        foundMeasuredOperand = foundMeasuredOperand or c.expression.isMeasured();
    }
    return foundMeasuredOperand;
}

@cached
operation EXPR!DecimalSwitchExpression isMeasured() : Boolean {
    var foundMeasuredOperand = false;
    if (self.defaultExpression.isDefined()) {
        foundMeasuredOperand = foundMeasuredOperand or self.defaultExpression.isMeasured();
    }
    for (c in self.cases) {
        foundMeasuredOperand = foundMeasuredOperand or c.expression.isMeasured();
    }
    return foundMeasuredOperand;
}

@cached
operation EXPR!Integer isMeasured() : Boolean {
    return false;
}

@cached
operation EXPR!Decimal isMeasured() : Boolean {
    return false;
}

@cached
operation EXPR!MeasuredInteger isMeasured() : Boolean {
    return true;
}

@cached
operation EXPR!MeasuredDecimal isMeasured() : Boolean {
    return true;
}

@cached
operation EXPR!IntegerAritmeticExpression getMeasure() {
    var leftMeasure = null;
    var rightMeasure = null;
    
    if (self.left.isMeasured()) {
        leftMeasure = self.left.getMeasure();
    }
    if (self.right.isMeasured()) {
        rightMeasure = self.right.getMeasure();
    }
    
    switch (self.operator) {
        case EXPR!IntegerOperator#add: continue;
        case EXPR!IntegerOperator#substract:
            if (leftMeasure == rightMeasure) {
                return leftMeasure;
            } else if (not leftMeasure.isDefined() or not rightMeasure.isDefined()) {
                "Addition of scalar and measured values is not allowed".println();
                return null;
            } else {
                ("Additional operands must match: " + leftMeasure.name + ", " + rightMeasure.name).println();
                return null;
            }
        case EXPR!IntegerOperator#multiply: continue;
        case EXPR!IntegerOperator#modulo: continue;
        case EXPR!IntegerOperator#divide:
            if (leftMeasure == rightMeasure) {
                return null;
            } else {
                var leftBases = Map{};
                if (leftMeasure.isDefined()) {
                    leftBases = leftMeasure.getBaseMeasures();
                }
                
                var rightBases = Map{};
                if (rightMeasure.isDefined()) {
                    rightBases = rightMeasure.getBaseMeasures();
                }
                
                var bases = new Map;
                for (m in leftBases.keySet()) {
                    bases.put(m, leftBases.get(m));
                }
                for (m in rightBases.keySet()) {
                    var exponent = rightBases.get(m);
                    var currentExponent = bases.get(m);
                    if (currentExponent.isDefined()) {
                        var newExponent;
                        switch (self.operator) {
                            case EXPR!IntegerOperator#multiply: newExponent = currentExponent + exponent;
                            case EXPR!IntegerOperator#modulo: newExponent = currentExponent - exponent;
                            case EXPR!IntegerOperator#divide: newExponent = currentExponent - exponent;
                        }
                        if (newExponent <> 0) {
                            bases.put(m, newExponent);
                        } else {
                            bases.remove(m);
                        }
                    } else {
                        switch (self.operator) {
                            case EXPR!IntegerOperator#multiply: bases.put(m, exponent);
                            case EXPR!IntegerOperator#modulo: bases.put(m, -exponent);
                            case EXPR!IntegerOperator#divide: bases.put(m, -exponent);
                        }
                        bases.put(m, exponent);
                    }
                }
                
                var m = getDimensions().get(bases);
                
                if (not m.isDefined()) {
                    ("No measure is defined for dimension: " + leftMeasure.name + self.operator + rightMeasure.name).println();
                }
                
                return m;
            }
        default: throw "Unsupported operation";
    }
}

@cached
operation EXPR!DecimalAritmeticExpression getMeasure() {
    var leftMeasure = null;
    var rightMeasure = null;
    
    if (self.left.isMeasured()) {
        leftMeasure = self.left.getMeasure();
    }
    if (self.right.isMeasured()) {
        rightMeasure = self.right.getMeasure();
    }
    
    switch (self.operator) {
        case EXPR!DecimalOperator#add: continue;
        case EXPR!DecimalOperator#substract:
            if (leftMeasure == rightMeasure) {
                return leftMeasure;
            } else if (not leftMeasure.isDefined() or not rightMeasure.isDefined()) {
                "Addition of scalar and measured values is not allowed".println();
                return null;
            } else {
                ("Additional operands must match: " + leftMeasure.name + ", " + rightMeasure.name).println();
                return null;
            }
        case EXPR!DecimalOperator#multiply: continue;
        case EXPR!DecimalOperator#divide:
            if (leftMeasure == rightMeasure) {
                return null;
            } else {
                var leftBases = Map{};
                if (leftMeasure.isDefined()) {
                    leftBases = leftMeasure.getBaseMeasures();
                }
                
                var rightBases = Map{};
                if (rightMeasure.isDefined()) {
                    rightBases = rightMeasure.getBaseMeasures();
                }

                var bases = new Map;
                for (m in leftBases.keySet()) {
                    bases.put(m, leftBases.get(m));
                }
                for (m in rightBases.keySet()) {
                    var exponent = rightBases.get(m);
                    var currentExponent = bases.get(m);
                    if (currentExponent.isDefined()) {
                        var newExponent;
                        switch (self.operator) {
                            case EXPR!DecimalOperator#multiply: newExponent = currentExponent + exponent;
                            case EXPR!DecimalOperator#divide: newExponent = currentExponent - exponent;
                        }
	                    if (newExponent <> 0) {
	                        bases.put(m, newExponent);
	                    } else {
	                        bases.remove(m);
	                    }
                    } else {
                        switch (self.operator) {
                            case EXPR!DecimalOperator#multiply: bases.put(m, exponent);
                            case EXPR!DecimalOperator#divide: bases.put(m, -exponent);
                        }
                    }
                }
                
                var m = getDimensions().get(bases);
                
                if (not m.isDefined()) {
                    ("No measure is defined for dimension: " + leftMeasure.name + self.operator + rightMeasure.name).println();
                }
                
                return m;
            }
        default: throw "Unsupported operation";
    }
}

@cached
operation EXPR!IntegerOppositeExpression getMeasure() {
    return self.expression.getMeasure();
}

@cached
operation EXPR!DecimalOppositeExpression getMeasure() {
    return self.expression.getMeasure();
}

@cached
operation EXPR!IntegerAggregatedExpression getMeasure() {
    return self.expression.getMeasure();
}

@cached
operation EXPR!DecimalAggregatedExpression getMeasure() {
    return self.expression.getMeasure();
}

@cached
operation EXPR!RoundExpression getMeasure() {
    return self.expression.getMeasure();
}

@cached
operation EXPR!IntegerSwitchExpression getMeasure() {
    var measure;
    
    for (c in self.cases) {
        var m = c.expression.getMeasure();
        if (measure.isDefined() and measure <> m) {
            return null;
        }
        measure = m;
    }
    
    if (self.defaultExpression.isDefined() and self.defaultExpression.getMeasure() <> measure) {
        return null;
    }
    
    return measure;
}

@cached
operation EXPR!DecimalSwitchExpression getMeasure() {
    var measure;
    
    for (c in self.cases) {
        var m = c.expression.getMeasure();
        if (measure.isDefined() and measure <> m) {
            return null;
        }
        measure = m;
    }
    
    if (self.defaultExpression.isDefined() and self.defaultExpression.getMeasure() <> measure) {
        return null;
    }
    
    return measure;
}

@cached
operation EXPR!Integer getMeasure() {
    return null;
}

@cached
operation EXPR!Decimal getMeasure() {
    return null;
}

@cached
operation EXPR!MeasuredInteger getMeasure() {
    return self.getMeasure();
}

@cached
operation EXPR!MeasuredDecimal getMeasure() {
    return self.getMeasure();
}
