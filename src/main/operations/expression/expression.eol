@cached
operation EXPR!SwitchCase getSwitchExpression() {
    return EXPR!SwitchExpression.all.selectOne(e | e.cases.contains(self));
}

@cached
operation EXPR!Expression getVariableName() : String {
    if (self.isKindOf(EXPR!Variable)) {
        return self.name;
    } else {
        var operandVariable = self.getOperands().selectOne(o | o.getVariableName().isDefined());
        if (operandVariable.isDefined()) {
            return operandVariable.getVariableName();
        }
    }
    return null;
}

// get operands of an expression
@cached
operation EXPR!Expression getOperands() : Collection {
    return Set{};
}

// get input (base) expressions 
/*@cached
operation EXPR!Expression getInputExpressions() : Collection {
    return Set{};
} */

// get collection of lambda expressions where the given object/collection expression is used as input variable
@cached
operation EXPR!ReferenceExpression getLambdaExpressions() : Collection {
    return Set{};
}

@cached
operation EXPR!Expression isComplete() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self) or (e.isKindOf(EXPR!ReferenceExpression) and e.getLambdaExpressions().contains(self))).isDefined();
}

@cached
operation EXPR!Expression isFragment() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self)).isDefined();
}

/*
@cached
operation EXPR!Expression getLambdaContainer() : EXPR!Expression {
    return EXPR!Expression.all.selectOne(e | e.getLambdaExpressions().contains(self));
}

@cached
operation EXPR!Expression getLambdaBaseContainer() : EXPR!Expression {
    var container = self.getLambdaContainer();
    if (not container.isDefined()) {
        return null;
    } else if (container.isDefined() and not container.getLambdaContainer().isDefined()) {
        return container;
    } else {
        return container.getLambdaBaseContainer();
    }
} */

@cached
operation EXPR!Expression getBaseExpressions() : Collection {
    var inputs = self.getOperands();
    if (not inputs.isEmpty()) {
        return inputs.collect(i | i.getBaseExpressions()).flatten();
    } else {
        return Set{self};
    }
}
