@cached
operation EXPR!SwitchCase getSwitchExpression() {
    return EXPR!SwitchExpression.all.selectOne(e | e.cases.contains(self));
}

// get operands of an expression
@cached
operation EXPR!Expression getOperands() : Collection {
    return Set{};
}

// get collection of lambda expressions where the given object/collection expression is used as input variable
@cached
operation EXPR!ReferenceExpression getLambdaExpressions() : Collection {
    return Set{};
}

@cached
operation EXPR!Expression isComplete() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self) or (e.isKindOf(EXPR!ReferenceExpression) and e.getLambdaExpressions().contains(self))).isDefined();
}

@cached
operation EXPR!Expression isFragment() : Boolean {
    return not EXPR!Expression.all.selectOne(e | e.getOperands().contains(self)).isDefined();
}

@cached
operation EXPR!Expression isLambdaExpression() : Boolean {
    return self.getLambdaContainer().isDefined();
}

@cached
operation EXPR!Expression getLambdaContainer() : EXPR!ReferenceExpression {
    return EXPR!ReferenceExpression.all.selectOne(e | e.getLambdaExpressions().contains(self));
}

@cached
operation EXPR!Expression getFragment() : EXPR!Expression {
    var fragment = EXPR!Expression.all.selectOne(e | e.getOperands().contains(self));
    if (fragment.isDefined()) {
        return fragment.getFragment();
    } else {
        return self;
    }
}

@cached
operation EXPR!Expression getBaseExpressions() : Collection {
    var inputs = self.getOperands();
    if (not inputs.isEmpty()) {
        return inputs.collect(i | i.getBaseExpressions()).flatten();
    } else {
        return Set{self};
    }
}

@cached
operation EXPR!Expression getLambdaBasePath() : Collection {
    if (not self.isLambdaExpression()) {
        return Set{};
    }
    
    //self.toString().println("LAMBDA: ");
    var result = new Set;
    
    var containers = Set{self.getLambdaContainer()};
    while (not containers.isEmpty()) {
        var basePathEntries = containers.collect(e | e.getOperands()).flatten();
        result.addAll(basePathEntries);
        //basePathEntries.collect(e | e.toString()).println(" - base path entries: ");
        //basePathEntries.collect(e | e.getFragment().toString()).println(" - fragments: ");
        
        containers = basePathEntries.collect(e | e.getFragment().getLambdaContainer()).select(e | e.isDefined());
    }
    
    return result;
}
